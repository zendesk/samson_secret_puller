#!/usr/bin/env ruby
STDOUT.sync = true
require_relative "../lib/secrets"

mounted_dir = "/vault-auth"
true_env = ['1', 'true']

vault_address_file = "#{mounted_dir}/address"
vault_address =
  if File.exist?(vault_address_file)
    File.read(vault_address_file).strip
  else
    ENV.fetch("VAULT_ADDR")
  end

vault_kv_version_file = "#{mounted_dir}/kv_version"
vault_v2 =
  if File.exist?(vault_kv_version_file)
    File.read(vault_kv_version_file).strip == "2"
  else
    true_env.include?(ENV["VAULT_KV_V2"])
  end

puts "Connecting to address: #{vault_address} v2: #{vault_v2}"

client = SecretsClient.new(
  vault_address: vault_address,
  vault_mount: ENV["VAULT_MOUNT"] || "secret",
  vault_prefix: ENV["VAULT_PREFIX"] || "apps",
  vault_authfile_path: ENV["VAULT_AUTH_FILE"] || "#{mounted_dir}/authsecret",
  ssl_verify: true_env.include?(ENV["VAULT_TLS_VERIFY"]),
  annotations: ENV["SECRET_ANNOTATIONS"] || '/secretkeys/annotations',
  serviceaccount_dir: ENV["SERVICEACCOUNT_DIR"] || '/var/run/secrets/kubernetes.io/serviceaccount/',
  output_path: ENV["SIDECAR_SECRET_PATH"] || '/secrets',
  api_url: (ENV["TESTING"] ? 'http://' : 'https://') + ENV.fetch("KUBERNETES_PORT_443_TCP_ADDR"),
  vault_v2: vault_v2
)

client.write_secrets
